Имеем два файла "flag.encrypt" и "encrypter.exe".

# flag.encrypt
Для начала взглянем на "flag.encrypt". "flag.encrypt" представляет собой текстовик с большим количеством каких-то данных в hex и десятичном формате, но если приглядется можно заметить какие-то "битые" симвволы.\
![ ](https://github.com/DomLev/rnd/blob/e79f8b488370701415fa9ed188c04ae174e06e1e/imgs/1.png)\
\
Осмотрев в hex редакторе эти "битые" зоны можно заметить что все они длинной 4 байта (запоминаем всю эту инфу, она очень важна).\
![ ](https://github.com/DomLev/rnd/blob/e79f8b488370701415fa9ed188c04ae174e06e1e/imgs/2.png)

# магия encrypter.exe часть 1
Это всё что есть интересного в файле флага, переходим к exe. Exe запустить не возможно без исправления "магии", поэтому открываем hex редактор и начинам чинить.\
Первое что можно заметить это то, что файл упакован upx, второе что первые два байта не верные, exe файлы начинаются с 4D 5A 90 (MZ.), а в нашем случае с 6D 7A 90 (mz.).\
Чиним перые байты и пробуем запускать и о чудо, он запустился и вывел подсказку.\
![ ](https://github.com/DomLev/rnd/blob/e79f8b488370701415fa9ed188c04ae174e06e1e/imgs/3.png)\
\
Пробуем скормить ему файл с фейк флагом(C0DEBY{Et0_Ne_Fl@g})и посмотрим на результат.\
![ ](https://github.com/DomLev/rnd/blob/e79f8b488370701415fa9ed188c04ae174e06e1e/imgs/4.png)\
\
В результате получаем что-то похожее на "flag.encrypt".

# магия encrypter.exe часть 2
Для дальнейшего осмотра encrypter нужно его распаковать, но попытки будут безуспешные.\
![ ](https://github.com/DomLev/rnd/blob/e79f8b488370701415fa9ed188c04ae174e06e1e/imgs/5.png)\
\
Время чинить "магиию" upx. Открывам hex редактор и вспоминаем как усроена структура upx файлов (или упаковываем рандомный exe файл и сраниваем). Нас интересует байты 43 44 42 21 (CDB!), правильное значение будет 55 50 58 21 (UPX!). После испрваления распаковываем.\
![ ](https://github.com/DomLev/rnd/blob/e79f8b488370701415fa9ed188c04ae174e06e1e/imgs/6.png)

# вскрытие encrypter.exe
Лёгкая часть закончилсь, время открывать дисассемблер. В моём случае будет ghidra. Осмотрев main обращаем внимение на 3 вызова почти в самом конце\
![ ](https://github.com/DomLev/rnd/blob/e79f8b488370701415fa9ed188c04ae174e06e1e/imgs/7.png)\
\
(все названия функций прописаны мной для удобства ориентирования). Логика программы следующая: открывается файл, чатается 100 байт из файла, щифруется (в функции encryptor 2 стадии), преобразовывается в числовые значания и записыается в файл с добавлением мусора и БАЙТ РАНДОМА которые понадобятся для расшифровывания (догадатся в каких частях фала записаны не сложно)\
кстати те значения которые прога выводила во время работы тоже являютя байтам рандома после нескольких запуска может показаться что эти значения одинаковые, но если внимательно посмотреть в функции шифрования можно заметить что они зависят от всемени.
# dencrypter.exe
После внимательного изучения внутреностей можно приступать к написанию декриптора, но есть нюансы на которых застряло много людей, а именно то что декриптор должен быть написан на C/C++ и скомпилен под винду.\
Для начала выпишем байты рандома.\
Следующим этапом является поиск зашифрованных данных, для этого вспоминаем что они имеют длинну всего 100 байт и имеют только числовые значения (или можно просто изучить структуру в функции записи и узнать что данные начинаются со смещением 0x3264)\
Но вот ещё один нюанс, так как данне из unsigned char были преобразованы в short short unsigned int (от 000 до 255) записанные данные будут в 3 раза длинее.\
Т.к нет особого желания городить разбитие строки в C, я использовал одну строчку питона ```[int(data[i:i+3]) for i in range(0, len(data), 3)]``` где data это найденая шифрованная строка.\
В итоге получаем массив из 100 значений, теперь напишем сам декриптор.\
В написании нет ничего сложного просто смотрим как прописано в крипторе и пишем также, но начинаем с конца.\
В одной из стадий шифрования есть вызов подлянки, его почти можно игнорировать, от туда нужно взять только возвращяемый результат, а точнее как он изменяется.\
Собираем и запускаем, т.к я на линуксе, буду использовать mingw и wine ```x86_64-w64-mingw32-gcc decryptor.c -o decryptor.exe``` ```wine decryptor.exe```.
![ ](https://github.com/DomLev/rnd/blob/e79f8b488370701415fa9ed188c04ae174e06e1e/imgs/8.png)
